<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MiB-NIRS-MuscleOxigenation: Project/LED.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MiB-NIRS-MuscleOxigenation
   </div>
   <div id="projectbrief">A firmware application for real-time monitoring of muscle oxygenation and hemodynamics during gait analysis using the AD MAX30101 and the STM32F303K8</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('_l_e_d_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">LED.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>GPIO-Based Status LED Control (PB3, STM32F303K8).  
<a href="#details">More...</a></p>

<p><a href="_l_e_d_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1eba03f25b9d10a66d906572d494d731" id="r_a1eba03f25b9d10a66d906572d494d731"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a1eba03f25b9d10a66d906572d494d731">LED_config</a> (void)</td></tr>
<tr class="memdesc:a1eba03f25b9d10a66d906572d494d731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize GPIO port B, pin 3 as push-pull output.  <br /></td></tr>
<tr class="memitem:a94ffebcdd3b5bbbf9a89e9f9ab52028d" id="r_a94ffebcdd3b5bbbf9a89e9f9ab52028d"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d">LED_On</a> (void)</td></tr>
<tr class="memdesc:a94ffebcdd3b5bbbf9a89e9f9ab52028d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive LED output HIGH (turn on).  <br /></td></tr>
<tr class="memitem:af842f9996045107cd0841a4f0707fc65" id="r_af842f9996045107cd0841a4f0707fc65"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#af842f9996045107cd0841a4f0707fc65">LED_Off</a> (void)</td></tr>
<tr class="memdesc:af842f9996045107cd0841a4f0707fc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive LED output LOW (turn off).  <br /></td></tr>
<tr class="memitem:a3b0db98f4b9d8da4c54223aa39ebc557" id="r_a3b0db98f4b9d8da4c54223aa39ebc557"><td class="memItemLeft">void&#160;</td><td class="memItemRight"><a class="el" href="#a3b0db98f4b9d8da4c54223aa39ebc557">LED_Toggle</a> (void)</td></tr>
<tr class="memdesc:a3b0db98f4b9d8da4c54223aa39ebc557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert LED output state (high ↔ low).  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>GPIO-Based Status LED Control (PB3, STM32F303K8). </p>
<p>Simple push-pull GPIO driver for visual feedback LED connected to port PB3.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
Hardware Interface</h3>
<ul>
<li><b>Port</b>: GPIOB</li>
<li><b>Pin</b>: PB3 (GPIO pin 3)</li>
<li><b>Mode</b>: Push-pull, no pull-up/pull-down</li>
<li><b>Output Type</b>: Standard CMOS push-pull (not open-drain)</li>
<li><b>Speed</b>: Default (Medium, ~2 MHz slew rate)</li>
<li><b>Voltage</b>: 3.3V (STM32F303 I/O level)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md11"></a>
Electrical Characteristics</h3>
<ul>
<li><b>Output HIGH</b>: 3.1-3.3 V (min ~3 mA source capability)</li>
<li><b>Output LOW</b>: 0.0-0.2 V (min ~3 mA sink capability)</li>
<li><b>Typical LED Circuit</b>: GPIO → 220Ω resistor → LED anode, LED cathode → GND</li>
<li><b>Max current per pin</b>: ±25 mA (STM32F303 absolute max)</li>
<li><b>Typical LED consumption</b>: ~10-20 mA (for standard 3mm/5mm LED)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
Usage Context</h3>
<ul>
<li><b>Primary purpose</b>: SysTick ISR feedback (100 ms toggle = 5 Hz blink)</li>
<li><b>Non-critical</b>: LED state does not affect sensor operation</li>
<li><b>No blocking</b>: All operations are non-blocking GPIO writes</li>
<li><b>Timing</b>: Register writes ~1 CPU cycle (&lt;20 ns)</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md13"></a>
Data Flow</h3>
<ol type="1">
<li><a class="el" href="#a1eba03f25b9d10a66d906572d494d731" title="Initialize GPIO port B, pin 3 as push-pull output.">LED_config()</a> → Enables GPIOB clock, sets PB3 as push-pull output</li>
<li><a class="el" href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d" title="Drive LED output HIGH (turn on).">LED_On()</a> → Sets ODR bit 3 (output high, LED on)</li>
<li><a class="el" href="#af842f9996045107cd0841a4f0707fc65" title="Drive LED output LOW (turn off).">LED_Off()</a> → Clears ODR bit 3 (output low, LED off)</li>
<li><a class="el" href="#a3b0db98f4b9d8da4c54223aa39ebc557" title="Invert LED output state (high ↔ low).">LED_Toggle()</a> → XORs ODR bit 3 (inverts state, called from SysTick ISR)</li>
</ol>
<dl class="section author"><dt>Author</dt><dd>Julio Fajardo </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2024-06-01 </dd></dl>
<dl class="section version"><dt>Version</dt><dd>2.0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Non-critical component; LED failures do not impact sensor or data acquisition </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo</a></b></dt><dd><p class="startdd">Add configurable blink patterns (multiple on/off cycles per ISR) </p>
<p class="enddd">Implement PWM dimming control (via timer PWM output) </p>
</dd></dl>

<p class="definition">Definition in file <a class="el" href="_l_e_d_8h_source.html">LED.h</a>.</p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a1eba03f25b9d10a66d906572d494d731" name="a1eba03f25b9d10a66d906572d494d731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eba03f25b9d10a66d906572d494d731">&#9670;&#160;</a></span>LED_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LED_config </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize GPIO port B, pin 3 as push-pull output. </p>
<p>One-time configuration:</p><ol type="1">
<li>Enable GPIOB clock (RCC-&gt;AHBENR |= RCC_AHBENR_GPIOBEN)</li>
<li>Configure PB3 as general-purpose output (MODER[7:6] = 01)</li>
<li>Implicitly push-pull (OTYPER[3] = 0 default)</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>@register_ops</p><ul>
<li>RCC-&gt;AHBENR |= RCC_AHBENR_GPIOBEN (Enable GPIOB clock)</li>
<li>Clear MODER[7:6] and MODER[9:8] (both PB3 and PB4 to avoid confusion)</li>
<li>Set MODER[7:6] = 01 (PB3 = general-purpose output)</li>
<li>OTYPER[3] remains 0 (push-pull, default)</li>
<li>OSPEEDR[3] = 0 (Medium speed ~2 MHz, default)</li>
</ul>
<p>@timing</p><ul>
<li>Clock enable: ~3 AHB cycles</li>
<li>Register writes: ~1 CPU cycle each</li>
<li>Total init time: &lt;1 µs</li>
</ul>
<p>@side_effects</p><ul>
<li>PB3 becomes output GPIO (unavailable for other uses: ADC, alternate functions)</li>
<li>GPIOB clock always enabled (minor power increase &lt;1 mA)</li>
<li>Initial PB3 state: LOW (LED off) after reset</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Call before using <a class="el" href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d" title="Drive LED output HIGH (turn on).">LED_On()</a>, <a class="el" href="#af842f9996045107cd0841a4f0707fc65" title="Drive LED output LOW (turn off).">LED_Off()</a>, or <a class="el" href="#a3b0db98f4b9d8da4c54223aa39ebc557" title="Invert LED output state (high ↔ low).">LED_Toggle()</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d" title="Drive LED output HIGH (turn on).">LED_On</a>, <a class="el" href="#af842f9996045107cd0841a4f0707fc65" title="Drive LED output LOW (turn off).">LED_Off</a>, <a class="el" href="#a3b0db98f4b9d8da4c54223aa39ebc557" title="Invert LED output state (high ↔ low).">LED_Toggle</a></dd></dl>
<p>Complete GPIO setup for LED control:</p><ol type="1">
<li><b>Enable GPIOB peripheral clock</b> (AHB domain)</li>
<li><b>Configure PB3 mode</b> (and accidentally PB4) as output</li>
<li><b>Verify open-drain</b> disabled (push-pull mode, OTYPER[3]=0)</li>
<li><b>Verify speed</b> at default (Medium ~2 MHz slew rate)</li>
<li>Ready for ODR writes (LED_On, LED_Off, LED_Toggle)</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8"></a>
Register Operations</h3>
<ul>
<li>RCC-&gt;AHBENR |= RCC_AHBENR_GPIOBEN Bit Enable: Transitions GPIOB from OFF to ON power state Effect: GPIO registers become readable/writable Latency: ~3 AHB cycles (~50 ns @ 64 MHz)</li>
<li>GPIOB-&gt;MODER &amp;= ~((3&lt;&lt;6)|(3&lt;&lt;8)) Clear bits [7:6] (PB3 mode) and [9:8] (PB4 mode) Purpose: Pre-existing driver uses PB4 for I2C alt-function Setting bits to 00 = input mode (will be overridden next)</li>
<li>GPIOB-&gt;MODER |= (1&lt;&lt;6) | (1&lt;&lt;8) Set bits [6]=1 (PB3 mode[0]=1) and [8]=1 (PB4 mode[0]=1) Result: MODER[7:6] = 01 (PB3 = output), MODER[9:8] = 01 (PB4 = output) Note: Bug? PB4 should be I2C; but empirically works with I2C after this</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md9"></a>
GPIO State After Config</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature  </th><th class="markdownTableHeadNone">PB3  </th><th class="markdownTableHeadNone">PB4  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Mode  </td><td class="markdownTableBodyNone">Output  </td><td class="markdownTableBodyNone">Output (but overridden I2C)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Type  </td><td class="markdownTableBodyNone">Push-pull  </td><td class="markdownTableBodyNone">Push-pull (OD disabled)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Speed  </td><td class="markdownTableBodyNone">Medium  </td><td class="markdownTableBodyNone">Medium  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Initial ODR  </td><td class="markdownTableBodyNone">0 (LOW)  </td><td class="markdownTableBodyNone">0 (LOW)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Pull  </td><td class="markdownTableBodyNone">None  </td><td class="markdownTableBodyNone">None  </td></tr>
</table>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>@timing</p><ul>
<li>Clock stabilization: ~3 AHB cycles</li>
<li>Register writes: ~1 cycle each (3 writes = 3 cycles)</li>
<li>Total: &lt;500 ns</li>
<li>PB3 ready for output: immediately after function returns</li>
</ul>
<p>@critical_notes</p><ul>
<li>Must be called AFTER clk_config() to ensure SYSCLK is stable at 64 MHz</li>
<li><a class="el" href="_i2_c_8h.html#aeb07abc3e8d8d8ad6b7e69cb4992dec8" title="Initialize I2C1 peripheral and GPIO pins.">I2C1_Config()</a> will overrun PB4 MODER bits but I2C still works (hardware multiplexing)</li>
<li>Order of initialization: clk_config() → <a class="el" href="#a1eba03f25b9d10a66d906572d494d731" title="Initialize GPIO port B, pin 3 as push-pull output.">LED_config()</a> → <a class="el" href="_i2_c_8h.html#aeb07abc3e8d8d8ad6b7e69cb4992dec8" title="Initialize I2C1 peripheral and GPIO pins.">I2C1_Config()</a></li>
<li>Calling <a class="el" href="#a1eba03f25b9d10a66d906572d494d731" title="Initialize GPIO port B, pin 3 as push-pull output.">LED_config()</a> after <a class="el" href="_i2_c_8h.html#aeb07abc3e8d8d8ad6b7e69cb4992dec8" title="Initialize I2C1 peripheral and GPIO pins.">I2C1_Config()</a> may disrupt I2C (MODER overwrite)</li>
</ul>
<p>@side_effects</p><ul>
<li>GPIOB clock permanently enabled (not disabled in low-power mode by default)</li>
<li>PB3 is now an output; cannot be used as input, ADC, or timer capture</li>
<li>PB3 starts LOW (LED off); no explicit <a class="el" href="#af842f9996045107cd0841a4f0707fc65" title="Drive LED output LOW (turn off).">LED_Off()</a> call needed</li>
<li>Draws ~1 mA additional idle current (GPIOB always powered)</li>
</ul>
<p>@power_note</p><ul>
<li>GPIOB active power: ~1 mA @ 3.3V (all 16 pins)</li>
<li>PB3 push-pull output (idle): &lt;1 µA when HIGH, &lt;1 µA when LOW</li>
<li>LED current: 10-20 mA typical (dominates GPIO current by ~100×)</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d" title="Drive LED output HIGH (turn on).">LED_On</a>, <a class="el" href="#af842f9996045107cd0841a4f0707fc65" title="Drive LED output LOW (turn off).">LED_Off</a>, <a class="el" href="#a3b0db98f4b9d8da4c54223aa39ebc557" title="Invert LED output state (high ↔ low).">LED_Toggle</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2_users_2juliofajardo_2_documents_2_a_r_m_2_slides_nuevos_2_n_i_r_s-_m_a_x30101_2_project_2main_8c-example.html#a8">/Users/juliofajardo/Documents/ARM/SlidesNuevos/NIRS-MAX30101/Project/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_e_d_8c_source.html#l00066">66</a> of file <a class="el" href="_l_e_d_8c_source.html">LED.c</a>.</p>

</div>
</div>
<a id="af842f9996045107cd0841a4f0707fc65" name="af842f9996045107cd0841a4f0707fc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af842f9996045107cd0841a4f0707fc65">&#9670;&#160;</a></span>LED_Off()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LED_Off </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drive LED output LOW (turn off). </p>
<p>Clears GPIO output register bit to low state. Non-blocking; takes one write to GPIO ODR register (~20 ns). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Safe to call repeatedly (bitwise AND is idempotent for already-clear bits) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d" title="Drive LED output HIGH (turn on).">LED_On</a>, <a class="el" href="#a3b0db98f4b9d8da4c54223aa39ebc557" title="Invert LED output state (high ↔ low).">LED_Toggle</a></dd></dl>
<p>Drive LED output LOW (turn off).</p>
<p>Clears GPIO output data register bit 3 to logical LOW (0 V). Push-pull driver sinks current from pin; LED reverse-biases (no current through LED → LED extinguishes).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>@operation</p><ul>
<li>GPIOB-&gt;ODR &amp;= ~(1&lt;&lt;3) (Bitwise AND with inverted mask ≈ AND with 0xFFF7)</li>
<li>Clears bit [3] and preserves all other ODR bits</li>
<li>Latency: ~1 CPU cycle + ~1 GPIO latch delay ≈ 30 ns @ 64 MHz</li>
<li>Non-blocking; function returns immediately</li>
</ul>
<p>@output_state</p><ul>
<li>PB3 voltage: 0.0-0.2 V (LOW)</li>
<li>PB3 current: -3 to -25 mA (sink capability; negative = into pin from external)</li>
<li>LED current: 0 mA (reverse bias; diode blocks current)</li>
<li>LED extinguishes (assuming proper hardware circuit with series resistor)</li>
</ul>
<p>@safe_repeated_calls</p><ul>
<li>Yes: Bitwise AND is idempotent</li>
<li>Calling <a class="el" href="#af842f9996045107cd0841a4f0707fc65" title="Drive LED output LOW (turn off).">LED_Off()</a> when already OFF has no effect (bit already clear)</li>
<li>No race conditions (single bit write in single cycle)</li>
</ul>
<p>@power_note</p><ul>
<li>Idle LOW state: pin sinks 0 mA (no LED current)</li>
<li>GPIO push-pull driver: ~1-2 mA internal power to hold pin LOW</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d" title="Drive LED output HIGH (turn on).">LED_On</a>, <a class="el" href="#a3b0db98f4b9d8da4c54223aa39ebc557" title="Invert LED output state (high ↔ low).">LED_Toggle</a>, <a class="el" href="#a1eba03f25b9d10a66d906572d494d731" title="Initialize GPIO port B, pin 3 as push-pull output.">LED_config</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_e_d_8c_source.html#l00140">140</a> of file <a class="el" href="_l_e_d_8c_source.html">LED.c</a>.</p>

</div>
</div>
<a id="a94ffebcdd3b5bbbf9a89e9f9ab52028d" name="a94ffebcdd3b5bbbf9a89e9f9ab52028d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d">&#9670;&#160;</a></span>LED_On()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LED_On </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drive LED output HIGH (turn on). </p>
<p>Sets GPIO output register bit to high state. Non-blocking; takes one write to GPIO ODR register (~20 ns). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Safe to call repeatedly (bitwise OR is idempotent for already-set bits) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af842f9996045107cd0841a4f0707fc65" title="Drive LED output LOW (turn off).">LED_Off</a>, <a class="el" href="#a3b0db98f4b9d8da4c54223aa39ebc557" title="Invert LED output state (high ↔ low).">LED_Toggle</a></dd></dl>
<p>Drive LED output HIGH (turn on).</p>
<p>Sets GPIO output data register bit 3 to logical HIGH (3.3 V). Push-pull driver sources current through pin; externally pulled to ground through LED + resistor for LED to illuminate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>@operation</p><ul>
<li>GPIOB-&gt;ODR |= (1&lt;&lt;3) (Bitwise OR with mask 0x0008)</li>
<li>Sets bit [3] and preserves all other ODR bits</li>
<li>Latency: ~1 CPU cycle + ~1 GPIO latch delay ≈ 30 ns @ 64 MHz</li>
<li>Non-blocking; function returns immediately</li>
</ul>
<p>@output_state</p><ul>
<li>PB3 voltage: 3.1-3.3 V (HIGH)</li>
<li>PB3 current: +3 to +25 mA (source capability, max = pin limit)</li>
<li>Typical LED current: 10-20 mA (limited by resistor R = (3.3V - V_LED) / I_LED)</li>
<li>LED illuminates (assuming proper hardware circuit)</li>
</ul>
<p>@safe_repeated_calls</p><ul>
<li>Yes: Bitwise OR with same bit is idempotent</li>
<li>Calling <a class="el" href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d" title="Drive LED output HIGH (turn on).">LED_On()</a> when already ON has no effect (bit already set)</li>
<li>No race conditions (single bit write in single cycle)</li>
</ul>
<p>@power_note</p><ul>
<li>Active HIGH state: pin sources 10-20 mA (via LED)</li>
<li>GPIO push-pull driver: ~3-5 mA internal power to drive pin HIGH</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af842f9996045107cd0841a4f0707fc65" title="Drive LED output LOW (turn off).">LED_Off</a>, <a class="el" href="#a3b0db98f4b9d8da4c54223aa39ebc557" title="Invert LED output state (high ↔ low).">LED_Toggle</a>, <a class="el" href="#a1eba03f25b9d10a66d906572d494d731" title="Initialize GPIO port B, pin 3 as push-pull output.">LED_config</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_l_e_d_8c_source.html#l00104">104</a> of file <a class="el" href="_l_e_d_8c_source.html">LED.c</a>.</p>

</div>
</div>
<a id="a3b0db98f4b9d8da4c54223aa39ebc557" name="a3b0db98f4b9d8da4c54223aa39ebc557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0db98f4b9d8da4c54223aa39ebc557">&#9670;&#160;</a></span>LED_Toggle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LED_Toggle </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert LED output state (high ↔ low). </p>
<p>XORs GPIO output register bit; used in periodic ISR for blink effect. Non-blocking; takes one RMW to GPIO ODR register (~30 ns). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Called from SysTick_Handler() every 100 ms for 5 Hz visual feedback </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d" title="Drive LED output HIGH (turn on).">LED_On</a>, <a class="el" href="#af842f9996045107cd0841a4f0707fc65" title="Drive LED output LOW (turn off).">LED_Off</a></dd></dl>
<p>Invert LED output state (high ↔ low).</p>
<p>Uses exclusive OR (XOR) to toggle GPIO output data register bit 3. Best practice for periodic blinking; used in SysTick ISR for 5 Hz visual feedback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<p>@operation</p><ul>
<li>GPIOB-&gt;ODR ^= (1&lt;&lt;3) (Bitwise XOR with mask 0x0008)</li>
<li>Flips bit [3]; all other ODR bits unchanged</li>
<li>Latency: ~2 CPU cycles (RMW = Read-Modify-Write)<ol type="1">
<li>Read current ODR value</li>
<li>XOR with 0x0008 (toggle bit 3)</li>
<li>Write back to ODR</li>
</ol>
</li>
<li>Total ≈ 30-50 ns @ 64 MHz (limited by GPIO latch delay, not CPU)</li>
<li>Non-blocking; function returns immediately</li>
</ul>
<p>@output_behavior </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Current State  </th><th class="markdownTableHeadNone">New State  </th><th class="markdownTableHeadNone">LED  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">HIGH (3.3 V)  </td><td class="markdownTableBodyNone">LOW (0 V)  </td><td class="markdownTableBodyNone">OFF  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">LOW (0 V)  </td><td class="markdownTableBodyNone">HIGH (3.3 V)  </td><td class="markdownTableBodyNone">ON  </td></tr>
</table>
<p>@call_context</p><ul>
<li><b>Primary</b>: SysTick_Handler() every 100 ms</li>
<li><b>Frequency</b>: ~10 Hz on-off transitions (20 Hz blink rate with 50/50 duty)</li>
<li><b>Visual effect</b>: 5 Hz blink (on 100 ms, off 100 ms)</li>
<li>Confirms system is alive and sampling running</li>
</ul>
<p>@timing_example </p><div class="fragment"><div class="line">SysTick_Handler()  T=0 ms:    <a class="code hl_function" href="#a3b0db98f4b9d8da4c54223aa39ebc557">LED_Toggle</a>() → if was ON, turn OFF</div>
<div class="line">SysTick_Handler()  T=100 ms:  <a class="code hl_function" href="#a3b0db98f4b9d8da4c54223aa39ebc557">LED_Toggle</a>() → if was OFF, turn ON</div>
<div class="line">SysTick_Handler()  T=200 ms:  <a class="code hl_function" href="#a3b0db98f4b9d8da4c54223aa39ebc557">LED_Toggle</a>() → if was ON, turn OFF</div>
<div class="line">...produces 5 Hz blink (100 ms on, 100 ms off)</div>
<div class="ttc" id="a_l_e_d_8h_html_a3b0db98f4b9d8da4c54223aa39ebc557"><div class="ttname"><a href="#a3b0db98f4b9d8da4c54223aa39ebc557">LED_Toggle</a></div><div class="ttdeci">void LED_Toggle(void)</div><div class="ttdoc">Invert LED output state (high ↔ low).</div><div class="ttdef"><b>Definition</b> <a href="_l_e_d_8c_source.html#l00200">LED.c:200</a></div></div>
</div><!-- fragment --><p>@atomic_safe</p><ul>
<li>Yes for single-pin toggle (RMW on single bit)</li>
<li>ISR-safe: Even if main loop calls LED_On/Off while ISR calls Toggle, worst case is transient misalignment; not critical for visual feedback</li>
</ul>
<p>@power_note</p><ul>
<li>Toggles between ON (~15 mA LED) and OFF (~0 mA LED)</li>
<li>Average power @ 5 Hz blink: ~7.5 mA (50% duty)</li>
<li>Negligible compared to sensor (entire system ~30-50 mA total)</li>
</ul>
<p>@intr_usage</p><ul>
<li>Called from: SysTick_Handler() (100 ms period)</li>
<li>No blocking or busy-waits (safe for ISR context)</li>
<li>No global state modified except GPIO ODR</li>
<li>No race conditions (GPIO ODR RMW is atomic per bit)</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a94ffebcdd3b5bbbf9a89e9f9ab52028d" title="Drive LED output HIGH (turn on).">LED_On</a>, <a class="el" href="#af842f9996045107cd0841a4f0707fc65" title="Drive LED output LOW (turn off).">LED_Off</a>, <a class="el" href="#a1eba03f25b9d10a66d906572d494d731" title="Initialize GPIO port B, pin 3 as push-pull output.">LED_config</a>, SysTick_Handler </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2_users_2juliofajardo_2_documents_2_a_r_m_2_slides_nuevos_2_n_i_r_s-_m_a_x30101_2_project_2main_8c-example.html#a10">/Users/juliofajardo/Documents/ARM/SlidesNuevos/NIRS-MAX30101/Project/main.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_l_e_d_8c_source.html#l00200">200</a> of file <a class="el" href="_l_e_d_8c_source.html">LED.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Project</b></li><li class="navelem"><a href="_l_e_d_8h.html">LED.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
