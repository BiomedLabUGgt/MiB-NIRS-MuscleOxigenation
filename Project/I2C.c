#include "I2C.h"
#include "stm32f303x8.h"

/**
/**
 * @brief Initialize I2C1 peripheral and GPIO pins for 400 kHz master-mode operation
 * @details Complete I2C1 setup sequence:
 *          1. Clock enables (I2C1, GPIOB)
 *          2. GPIO configuration (open-drain, alternate function AF4)
 *          3. I2C peripheral reset
 *          4. Timing register configuration for 400 kHz
 *          5. Enable I2C1
 *
 * ### GPIO Configuration (PB6 = SCL, PB7 = SDA)
 *  - MODER: [14:12]=10 (Alternate Function), [14:12]=10
 *  - OTYPER: [7]=1 (Open-drain), [6]=1
 *  - AFR[0]: [31:28]=0100 (AF4), [27:24]=0100 (AF4)
 *
 * ### I2C TIMINGR = 0x00C50F26 (for APB1 = 32 MHz, target 400 kHz)
 *  - PRESC[3:0] = 0 (Prescaler = 1)
 *  - SCLDEL[3:0] = 1010 (Setup delay ≈ 640 ns)
 *  - SDADEL[3:0] = 0101 (Hold delay ≈ 320 ns)
 *  - SCLH[7:0] = 00001111 (SCL high ≈ 1.5 µs)
 *  - SCLL[7:0] = 00100110 (SCL low ≈ 1.0 µs)
 *  - Calculated frequency: ~400 kHz (I2C Fast-mode)
 *
 * @param None
 * @return void
 * @retval N/A
 *
 * @timing
 *  - Total init time: <1 ms
 *  - I2C1 ready after: function completes
 *  - First I2C transaction: can follow immediately
 *
 * @critical_sequence
 *  - I2C clock MUST be enabled before TIMINGR modification
 *  - GPIO pins must be configured as open-drain (not push-pull)
 *  - Reset sequence (RSTR flag) clears any prior error states
 *  - TIMINGR is APB1-frequency-sensitive; changing APB1 requires recalculation
 *
 * @side_effects
 *  - PB6 and PB7 become I2C1 pins (unavailable for GPIO)
 *  - I2C1 clock enabled in RCC->APB1ENR
 *  - I2C1 will hold SCL/SDA low if bus is busy
 *
 * @warning
 *  - Call once at system startup, BEFORE any I2C_Write/Read operations
 *  - Do not change TIMINGR if APB1 frequency changes dynamically
 *  - External pull-up resistors (~4.7 kΩ) required on SCL/SDA lines
 *
 * @see I2C1_Write, I2C1_Read
 */

void I2C1_Config(void) {
    // Enable I2C1 clock
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
    // Enable GPIOB clock
    RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
    // Configure PB6 (SCL) and PB7 (SDA) as open-drain alternate function
    // Clear mode bits for PB6 and PB7
    GPIOB->MODER &= ~((3 << 12) | (3 << 14));
    // Set to alternate function (10)
    GPIOB->MODER |= (2 << 12) | (2 << 14);
    // Set open-drain output type
    GPIOB->OTYPER |= (1 << 6) | (1 << 7);
    // Set alternate function to I2C1 (AF4 for PB6 and PB7)
    GPIOB->AFR[0] &= ~((0xF << 24) | (0xF << 28));
    GPIOB->AFR[0] |= (4 << 24) | (4 << 28);
    // Reset I2C1
    RCC->APB1RSTR |= RCC_APB1RSTR_I2C1RST;
    RCC->APB1RSTR &= ~RCC_APB1RSTR_I2C1RST;
    // Disable I2C1 to configure it
    I2C1->CR1 &= ~I2C_CR1_PE;
    // TIMINGR register for 400 kHz with APB1 = 32 MHz
    // (PRESC=0, SCLDEL=12, SDADEL=5, SCLH=15, SCLL=38)
    I2C1->TIMINGR = 0x00C50F26;
    // Enable I2C1
    I2C1->CR1 |= I2C_CR1_PE;
}


/**
 * @brief Master write single 8-bit register + data byte to I2C slave
 * @details Performs standard I2C write transaction with automatic STOP condition:
 *          1. Wait for bus available (ISR.BUSY clear)
 *          2. Configure CR2: 2 bytes, AUTOEND, START condition
 *          3. Send register address (TXDR)
 *          4. Send data byte (TXDR)
 *          5. Wait for TXE (transmitter empty); AUTOEND triggers STOP
 *
 * ### Transaction Sequence
 *  ```
 *  START [slave_addr(W)] ACK [register_addr] ACK [data_byte] ACK STOP
 *  ```
 *  - START: Generated by CR2.START
 *  - slave_addr: Shifted left 1 bit by hardware; (slave<<1) or slave|0
 *  - AUTOEND: Automatically generates STOP after NBYTES bytes sent
 *
 * @param slave - 7-bit I2C slave address (e.g., 0x5D for MAX30101)
 *                Format: [D6:D0] (do NOT pre-shift)
 * @param addr - Register address (0x00-0xFF) in slave device
 * @param data - Single data byte to write (0x00-0xFF)
 * @return void
 * @retval N/A (blocking until complete or bus error)
 *
 * @timing
 *  - Bus arbitration: 1-2 µs
 *  - Byte transmission (2×): ~10 µs each = 20 µs
 *  - ACK/STOP wait: ~10 µs
 *  - **Total latency**: ~30-50 µs (typical)
 *  - Maximum timeout (bus error): ~1 sec (hardware dependent)
 *
 * @flags_monitored
 *  - BUSY: Wait until clear (bus available)
 *  - TXIS: Transmit interrupt status, fires per byte ready to send
 *  - TXE: Transmitter empty, fires after last byte enqueued
 *  - AUTOEND: Firmware-set flag; hardware auto-clears and generates STOP
 *
 * @error_conditions
 *  - **NAK received**: Bus hangs in BUSY state; requires I2C reset (see datasheet)
 *  - **Slave not present**: Timeout; TXE may never set
 *  - **SDA stuck low**: Requires manual GPIO toggle to recover
 *
 * @usage_example
 *  ```
 *  // Write LED power control register to MAX30101
 *  I2C1_Write(0x5D, LED1_PAMPLI, 0x3F);  // slave=0x5D, addr=0x0C, data=0x3F
 *  ```
 *
 * @see I2C1_Read, I2C specification (NXP UM10204)
 */
void I2C1_Write(uint8_t slave, uint8_t addr, uint8_t data){
    // Wait for bus to be available
    while(I2C1->ISR & I2C_ISR_BUSY);
    // Set up transfer: slave address, 2 bytes, AUTOEND, START
    I2C1->CR2 = 0x00;
    I2C1->CR2 = I2C_CR2_AUTOEND | (2<<16) | (slave<<1) | I2C_CR2_START;
    // Send register address
    while(!(I2C1->ISR & I2C_ISR_TXIS));
    I2C1->TXDR = addr;
    // Send data byte
    while(!(I2C1->ISR & I2C_ISR_TXIS));
    I2C1->TXDR = data;
    // Wait for transmission complete
    while(!(I2C1->ISR & I2C_ISR_TXE));
}

/**
 * @brief Master read multiple bytes from I2C slave register (repeated START)
 * @details Performs combined write-read transaction without bus release:
 *          **Phase 1 (Write)**:
 *            1. Configure CR2: 1 byte, NO AUTOEND, START condition
 *            2. Send register address
 *            3. Wait for TC (transfer complete, not TXE)
 *          **Phase 2 (Repeated START + Read)**:
 *            1. Configure CR2: RD_WRN=1, size bytes, AUTOEND, START condition
 *            2. Read each byte from RXDR (data available via RXNE flag)
 *            3. Wait for STOPF (AUTOEND triggers STOP)
 *
 * ### Transaction Sequence
 *  ```
 *  START [slave_addr(W)] ACK [register_addr] ACK
 *  RESTART [slave_addr(R)] ACK [data_0] ACK [data_1] ACK ... STOP
 *  ```
 *  - Repeated START: Avoids releasing bus; allows atomic address+read
 *  - RD_WRN: Set for read phase; hardware handles address bit automatically
 *
 * @param slave - 7-bit I2C slave address (e.g., 0x5D for MAX30101)
 *                Format: [D6:D0] (do NOT pre-shift)
 * @param addr - Register address in slave device to read from (e.g., 0x07 for MAX30101 FIFO)
 * @param data - [out] Pointer to buffer for received bytes
 *               Must be allocated by caller with capacity ≥ size bytes
 * @param size - [in] Number of bytes to read from slave (1-255)
 *               Typical values: 1 (single register), 6 (MAX30101 FIFO sample)
 * @return void
 * @retval N/A (blocking until complete or error)
 *
 * @timing
 *  - Write address phase: ~15-20 µs
 *  - Repeated START latency: ~10-15 µs
 *  - Read phase (per byte): ~10-15 µs
 *  - **Total latency**: 100+ 30×size µs (typical)
 *  - Example: Read 6 bytes ≈ 180-200 µs
 *  - Dominates any sensor timing; I2C is bottleneck at 100 Hz sampling
 *
 * @flags_monitored
 *  - BUSY: Wait until clear before write phase
 *  - TXIS: Ready for register address byte
 *  - TC (not TXE!): Critical; signals address byte sent, allowing repeated START
 *  - RXNE: Data byte available in RXDR
 *  - STOPF: AUTOEND triggered; read phase complete
 *
 * @error_conditions
 *  - **Register address invalid**: Slave NAKs; BUSY remains set
 *  - **No slave at address**: BUSY hangs indefinitely (no timeout)
 *  - **Buffer overflow**: Caller must ensure data[] size ≥ size parameter
 *  - **Timeout on RXNE**: Slave not responding; function blocks forever
 *
 * @performance_note
 *  - Read 32 FIFO samples (192 bytes): ~6 milliseconds
 *  - Pure I2C time at 100 Hz ÷ 32 samples = dominant ISR latency
 *  - Consider DMA or firmware optimization for high-speed sampling
 *
 * @usage_example
 *  ```
 *  // Read 6 bytes from MAX30101 FIFO (one sample, 3 channels × 2 bytes)
 *  uint8_t fifo_data[6];
 *  I2C1_Read(0x5D, 0x07, fifo_data, 6);
 *  // fifo_data[0] = red[MSB], fifo_data[1] = red[LSB], ...
 *  ```
 *
 * @see I2C1_Write, I2C specification (repeated START section)
 */
void I2C1_Read(uint8_t slave, uint8_t addr, uint8_t *data, uint8_t size){
    // Wait for bus to be available
    while(I2C1->ISR & I2C_ISR_BUSY);
    // Send register address (write 1 byte, no AUTOEND for repeated START)
    I2C1->CR2 = 0x00;
    I2C1->CR2 = (1<<16) | (slave<<1) | I2C_CR2_START;
    // Send register address
    while(!(I2C1->ISR & I2C_ISR_TXIS));
    I2C1->TXDR = addr;
    // Wait for transfer complete (TC flag)
    while(!(I2C1->ISR & I2C_ISR_TC));
    // Read data (multiple bytes, AUTOEND, RD_WRN=1)
    I2C1->CR2 = 0x00;
    I2C1->CR2 = I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | (size<<16) | (slave<<1) | I2C_CR2_START;
    // Read each byte
    for(uint8_t i = 0; i < size; i++){
        // Wait for data ready
        while(!(I2C1->ISR & I2C_ISR_RXNE));
        data[i] = I2C1->RXDR;
    }
    // Wait for stop condition
    while(!(I2C1->ISR & I2C_ISR_STOPF));
}
